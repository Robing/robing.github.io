
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Rainer's blog</title>
  <meta name="author" content="Robin">

  
  <meta name="description" content="介绍 Web 组件是一系列前沿规范，它： 使得构建部件(widget)成为可能
…重用更为可靠 …即便后续版本的组件修改了内部实现细节也不会使页面出错。 这是否意味着你得决定什么时候用 HTML/JavaScript，什么时候用 Web 组件？不！HTML 和 JavaScript &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://Robing.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Rainer's blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Rainer's blog</a></h1>
  
    <h2>Focus on Html5 css3 mobile development</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:Robing.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/16/shadow-dom-101/">Shadow DOM 101</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-16T10:09:17+08:00" pubdate data-updated="true">May 16<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class="content" id="article-content">        
<p></p>

<h2 id="toc-introduction">介绍</h2>

<p>
Web 组件是一系列前沿规范，它：
</p>

<ol>
<li>使得构建部件(widget)成为可能</li>
<li>…重用更为可靠</li>
<li>
…即便后续版本的组件修改了内部实现细节也不会使页面出错。
</li>
</ol>

<p>
这是否意味着你得决定什么时候用 HTML/JavaScript，什么时候用 Web 组件？不！HTML 和 JavaScript 可以制作交互式可视化内容，
部件也是交互式可视化内容。在开发部件的过程中自然而然的就会利用你的 HTML 和 JavaScript 技巧。Web 组件标准就是以此为目的而设计的。
</p>

<blockquote class="commentary talkinghead">
若是使用别的技术来构建部件却也说不通。比如，我就肯定不会推荐你用 <code>&lt;canvas&gt;</code> 来写部件。它确实可靠——如果你修改绘制的内容也不会破坏页面——但它对可访问性(accessibility)，索引(indexing)，组合(composition)，分辨率无关(resolution independence)都不友好。
</blockquote>

<p>
但有个根本问题，导致 HTML 和 JavaScript 构建出来的部件难以使用：部件中的 DOM 树并没有封装起来。
封装的缺乏意味着文档中的样式表会无意中影响部件中的某些部分；
JavaScript 可能在无意中修改部件中的某些部分；你书写的 ID 也可能会把部件内部的 ID 覆盖。
</p>

<blockquote class="commentary">
缺乏封装的一个明显缺点在于：如果你更新了库或者部件的 DOM 更改了内部细节，你的样式和脚本就可能在不经意间遭到破坏。
</blockquote>

<p>
Web 组件由四部分组成：
</p>

<ol>
<li><a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html">Templates</a></li>
<li><a href="http://www.w3.org/TR/shadow-dom/">Shadow
DOM</a></li>
<li><a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/index.html">Custom
Elements</a></li>
<li><a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/explainer/index.html#external-custom-elements-and-decorators">Packaging</a></li>
</ol>

<p>
<b>Shadow DOM</b> 解决了 DOM 树的封装问题。Web 组件的四部分被设计成配合工作，但你也可以选择 Web 组件中的某个部分来使用。该教程将教会你如何使用 Shadow DOM。
</p>

<p class="notice">
<b>注意：</b> Chrome 25+ 支持 Shadow DOM，但 API 需要加 <code>webkit</code> 前缀。 在 Chrome 的最新版本中增加了无前缀的 API，可以通过开启 <code>about:flags</code> 下的 &#8220;实验性网络平台功能&#8221;来使用。
</p>

<h2 id="toc-hello-world">Hello, Shadow World</h2>

<p>
有了 Shadow DOM，元素就可以和一个新类型的节点关联。这个新类型的节点称为 <b>shadow root。</b>与一个 shadow root 关联的元素称作一个 <b>shadow host。</b>shadow host 的内容不会渲染；shadow root 的内容会渲染。
</p>
</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/05/16/shadow-dom-101/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/15/css3-animation/">Css3 Animation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-15T22:28:04+08:00" pubdate data-updated="true">May 15<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Introduction</h3>




<p>Ladies and gentlemen, it is the second decade of the second millennium and we are still kicking around the same 2D interface we got three decades ago. Sure, Apple debuted a few apps for OSX 10.7 that have a couple more 3D flourishes, and Microsoft has had thatFlip 3Dfor a while. But c’mon, 2011 is right around the corner. That’sTwenty Elevenfolks. Where is our 3D virtual reality? By now, we should be zipping around theMetaverse in super-sonic motorbikes.</p>




<p>Granted, the capability of rendering complex 3D environments has been present for years. On the Web, there already are number of solutions –Flash,three.jsin canvas, and eventually WebGL. And finally, we meager front-end developers have our own three-dimensional jewel: CSS 3D Transforms!</p>




<h3>Rationale</h3>




<p>Like a beautiful jewel, 3D transform can be dazzling, a true spectacle to behold. But before we start tacking 3D diamonds and rubies to our compositions like Liberace’s tailor, we owe it to our users to ask what can they benefit from this awesome feature.</p>




<p>The entire application does not, and should not, take advantage of 3D. CSS was built to style documents, not generate explorable environments. I fail to find a benefit to filling out a web form that can be accessed by swiveling my viewport to the Sign-Up Room (although there have been proposals to make the Web just that). However, there is plenty of opportunity to use 3D transformsin betweenthe interface, via transitions.</p>




<p>Take for instance the Weather App on the iPhone. The application uses two views: a details view and an options view. Switching between these two views is done with a 3D flip transition. This affords the user that the interface has two and only two views, as they can only exist on either side of the same plane.</p>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/05/15/css3-animation/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/05/16/shadow-dom-101/">Shadow DOM 101</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/15/css3-animation/">Css3 Animation</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Robin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
